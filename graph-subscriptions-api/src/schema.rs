use anyhow::{Ok, Result};
use async_graphql::{Context, EmptyMutation, EmptySubscription, Enum, Object, Schema};
use chrono::Utc;
use toolshed::bytes::{Address, Bytes32, DeploymentId};

use crate::network_subgraph::{GraphAccount, Subgraph, SubgraphDeployments};

pub struct GraphSubscriptionsSchemaCtx {
    pub subgraph_deployments: SubgraphDeployments,
}

pub type GraphSubscriptionsSchema = Schema<QueryRoot, EmptyMutation, EmptySubscription>;

#[derive(Enum, Clone, Copy, PartialEq, Eq)]
pub enum OrderDirection {
    Asc,
    Desc,
}

#[Object]
impl GraphAccount {
    async fn id(&self) -> String {
        self.id.to_string()
    }
    async fn image(&self) -> &Option<String> {
        &self.image
    }
    async fn default_display_name(&self) -> &Option<String> {
        &self.default_display_name
    }
}

#[Object]
impl Subgraph {
    async fn id(&self) -> String {
        self.id.to_string()
    }
    async fn display_name(&self) -> &Option<String> {
        &self.display_name
    }
    async fn image(&self) -> &Option<String> {
        &self.image
    }
    async fn owner(&self) -> &GraphAccount {
        &self.owner
    }
}

pub struct RequestTicket {
    pub id: Bytes32,
    pub owner: Address,
    pub display_name: String,
}

#[Object]
/// The RequestTicket is a derived structure that represents fields derived from a user querying a Subgraph on The Graph Network.
/// After a user subscribes to The Graph Subscriptions Contract, they can then sign an EIP-712 domain message and use this to query Subgraphs on The Graph Network.
/// When a gateway receives the query, with this request ticket, it pushes data about the query to logs.
/// This api then queries the data from those logs to build this structure.
impl RequestTicket {
    /// Generated Bytes32 ID from the: {user wallet address}:{request ticket name}
    async fn id(&self) -> String {
        self.id.to_string()
    }
    /// The wallet address of the user who owns the request ticket/signed the message
    async fn owner(&self) -> String {
        self.owner.to_string()
    }
    /// The user-chosen, friendly, name of the request ticket.
    /// This value is not stored on-chain. It is selected filled out by the user when they sign the EIP-712 message.
    async fn display_name(&self) -> &String {
        &self.display_name
    }
    /// Count of all of the `Subgraphs` queried by the request ticket.
    async fn queried_subgraphs_count<'ctx>(&self, _ctx: &Context<'ctx>) -> i64 {
        0
    }
    /// List of `Subgraph` records that this request ticket queried.
    async fn queried_subgraphs<'ctx>(
        &self,
        _ctx: &Context<'ctx>,
        _first: Option<i32>,
        _skip: Option<i32>,
    ) -> Option<Vec<Subgraph>> {
        None
    }
    /// Total count of queries performed, across all `Subgraphs`, using this request ticket
    async fn total_query_count<'ctx>(&self, _ctx: &Context<'ctx>) -> u64 {
        0
    }
    /// Percentage of queries used for the user's active subscription.
    /// An active subscription stores the start and end block timestamp as well as a query rate that the user is paying for on-chain (in the Subscriptions contract).
    /// As the user queries `Subgraphs` using their request ticket, they "use up" part of their paid for rate (which is more of a way to rate-limit querying),
    /// in the given time-period.
    /// This value represents the percentage (from 0.00 -> 1.00) of the rate that has been used by the amount of queries made with the request ticket.
    async fn query_rate_used_percentage<'ctx>(&self, _ctx: &Context<'ctx>) -> f32 {
        0.00
    }
    /// Unix-timestamp of the last query performed using this request ticket
    async fn last_query_timestamp<'ctx>(&self, _ctx: &Context<'ctx>) -> i64 {
        Utc::now().timestamp()
    }
}

#[derive(Enum, Clone, Copy, PartialEq, Eq)]
pub enum RequestTicketOrderBy {
    Id,
    Owner,
    DisplayName,
}

pub struct RequestTicketStat {
    pub id: Bytes32,
    pub request_ticket_id: Bytes32,
    pub start: i64,
    pub end: i64,
    pub total_query_count: u64,
}

#[Object]
impl RequestTicketStat {
    /// Generated Bytes32 ID from the: {user wallet address}:{request ticket name}:{integer}
    async fn id(&self) -> String {
        self.id.to_string()
    }
    /// The Request Ticket Derived ID
    async fn request_ticket_id(&self) -> String {
        self.request_ticket_id.to_string()
    }
    /// The start unix-timestamp date range of aggregated stats
    async fn start(&self) -> i64 {
        self.start
    }
    /// The end unix-timestamp date range of the aggregated stats
    async fn end(&self) -> i64 {
        self.end
    }
    /// The total count of queries received in the given date range using the RequestTicket
    async fn total_query_count(&self) -> u64 {
        self.total_query_count
    }
}

#[derive(Enum, Clone, Copy, PartialEq, Eq)]
pub enum RequestTicketStatOrderBy {
    Id,
    RequestTicketId,
    Start,
    End,
    TotalQueryCount,
}

pub struct RequestTicketSubgraphStat {
    pub id: Bytes32,
    pub request_ticket_id: Bytes32,
    pub start: i64,
    pub end: i64,
    pub total_query_count: u64,
    pub subgraph_deployment_id: DeploymentId,
}

#[Object]
impl RequestTicketSubgraphStat {
    /// Generated Bytes32 ID from the: {user wallet address}:{request ticket name}:{integer}
    async fn id(&self) -> String {
        self.id.to_string()
    }
    /// The Request Ticket Derived ID
    async fn request_ticket_id(&self) -> String {
        self.request_ticket_id.to_string()
    }
    /// The start unix-timestamp date range of aggregated stats
    async fn start(&self) -> i64 {
        self.start
    }
    /// The end unix-timestamp date range of the aggregated stats
    async fn end(&self) -> i64 {
        self.end
    }
    /// The total count of queries received in the given date range using the RequestTicket
    async fn total_query_count(&self) -> u64 {
        self.total_query_count
    }
    /// The `SubgraphDeployment` the user queried with the RequestTicket
    async fn subgraph_deployment_id(&self) -> String {
        self.subgraph_deployment_id.to_string()
    }
    /// List of `Subgraphs` associated to the `SubgraphDeployment` that the user queried
    async fn subgraphs<'ctx>(&self, ctx: &Context<'ctx>) -> Option<Vec<Subgraph>> {
        if self.subgraph_deployment_id.is_empty() {
            return None;
        }
        let schema_ctx = ctx.data_unchecked::<GraphSubscriptionsSchemaCtx>();
        schema_ctx
            .subgraph_deployments
            .deployment_subgraphs(&self.subgraph_deployment_id)
            .await
    }
}

#[derive(Enum, Clone, Copy, PartialEq, Eq)]
pub enum RequestTicketSubgraphStatOrderBy {
    Id,
    RequestTicketId,
    Start,
    End,
    TotalQueryCount,
    SubgraphDeploymentId,
}

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    /// A list of Request Tickets for the authenticated user, found by their wallet address (parsed from the Authorization header).
    async fn user_request_tickets<'ctx>(
        &self,
        _ctx: &Context<'ctx>,
        _first: Option<i32>,
        _skip: Option<i32>,
        _order_by: Option<RequestTicketOrderBy>,
        _order_direction: Option<OrderDirection>,
    ) -> Result<Vec<RequestTicket>> {
        Ok(vec![])
    }
    /// A list of aggregated query stats, by timerange, for the request ticket parsed from the Authorization header.
    async fn request_ticket_stats<'ctx>(
        &self,
        _ctx: &Context<'ctx>,
        _first: Option<i32>,
        _skip: Option<i32>,
        _order_by: Option<RequestTicketStatOrderBy>,
        _order_direction: Option<OrderDirection>,
    ) -> Result<Vec<RequestTicketStat>> {
        Ok(vec![])
    }
    /// A list of aggregated query stats, by timerange, for a specific subgraph deployment, for the request ticket parsed from the Authorization header.
    async fn request_ticket_subgraph_stats<'ctx>(
        &self,
        _ctx: &Context<'ctx>,
        _subgraph_deployment_id: String,
        _first: Option<i32>,
        _skip: Option<i32>,
        _order_by: Option<RequestTicketSubgraphStatOrderBy>,
        _order_direction: Option<OrderDirection>,
    ) -> Result<Vec<RequestTicketSubgraphStat>> {
        Ok(vec![])
    }
}
